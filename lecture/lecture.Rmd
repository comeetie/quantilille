---
title: "**Atelier R** Cartographie"
author: "Kim Antunez, Etienne Côme"
date: "**QuantiLille** Juin 2021"
output: 
  rmdformats::robobook:
    highlight: kate
    thumbnails: false
    lightbox: false
    gallery: false
    selfcontained: true
editor_options: 
  chunk_output_type: console
---

# L'écosystème spatial sur R 

## Introduction à `sf` 

* Site web de `sf`: [Simple Features for R](https://r-spatial.github.io/sf/index.html)

* sf pour Simple Features
* Sortie en octobre 2016

* A pour but de rassembler les fonctionnalités d'anciens packages (`sp`, `rgeos` and `rgdal`) en un seul

* Facilite la manipulation de données spatiales, avec des objets simples. 
* [Tidy data](http://vita.had.co.nz/papers/tidy-data.html): compatible avec la syntaxe pipe ` %>% ` et les opérateurs du `tidyverse`.

* Principal auteur et mainteneur : Edzer Pebesma (également auteur du package `sp`)

</br>
**la structure des objets sf : **

<img src="img/sf.png" alt="format sf" width="100%">


## Importer / exporter des données 
```{r}
library(sf)
mtq <- read_sf("data/mtq/martinique.shp")
mtq <- st_read("data/mtq/martinique.shp")
write_sf(mtq,"data/mtq/martinique.gpkg",delete_layer = TRUE)
st_write(mtq,"data/mtq/martinique.gpkg",delete_layer = TRUE)
```


## Système de coordonées
Les projections/système de coordonées sont répertoriées grâce à un code le code epsg :

- lat/long : 4326 https://epsg.io/4326
- Lambert 93 : 2154 https://epsg.io/2154
- Pseudo-Mercator : 3857 https://epsg.io/3857
- Lambert azimuthal equal area : 3035 https://epsg.io/3035

## Projection 

Obtenir la projection en utilisant `st_crs()` ([code epsg](https://epsg.io/)) et la modifier en utilisant `st_transform()`.

```{r}
st_crs(mtq)
mtq_4326 <- mtq %>% st_transform(4326)
```

## Afficher les données

Affichage par défaut : 

```{r, nm=TRUE}
plot(mtq)
```


En ne gardant que la géométrie : 

```{r, nm=TRUE}
plot(st_geometry(mtq))
```

## Extraire les centroïdes

```{r, nm=TRUE}
mtq_c <- st_centroid(mtq)
plot(st_geometry(mtq))
plot(st_geometry(mtq_c), add=TRUE, cex=1.2, col="red", pch=20)
```

## Matrice de distance
```{r, nm=TRUE}
mat <- st_distance(x=mtq_c,y=mtq_c)
mat[1:5,1:5]
```

## Agrégation de polygones 

Union simple  : 
```{r, nm=TRUE}
mtq_u <- st_union(mtq)
plot(st_geometry(mtq), col="lightblue")
plot(st_geometry(mtq_u), add=T, lwd=2, border = "red")
```

A partir d'une variable de regroupement : 

```{r, nm=TRUE}
library(dplyr)
mtq_u2 <- mtq %>% 
  group_by(STATUT) %>% 
  summarize(P13_POP = sum(P13_POP))
plot(st_geometry(mtq), col="lightblue")
plot(st_geometry(mtq_u2), add=T, lwd=2, border = "red", col=NA)
```

## Zone tampon 

```{r, nm=TRUE}
mtq_b <- st_buffer(x = mtq_u, dist = 5000)
plot(st_geometry(mtq), col="lightblue")
plot(st_geometry(mtq_u), add=T, lwd=2)
plot(st_geometry(mtq_b), add=T, lwd=2, border = "red")
```

## Intersection de polygones 

```{r, nm=TRUE}
# create a polygon
m <- rbind(c(700015,1624212), c(700015,1641586), c(719127,1641586), 
           c(719127,1624212), c(700015,1624212))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq))
plot(st_geometry(mtq))
plot(p, border="red", lwd=2, add=T)
```

`st_intersection()` extrait la partie de `mtq` qui s'intersecte avec le polygone créé.  

```{r, nm=TRUE, warning=F}
mtq_z <- st_intersection(x = mtq, y = p)
plot(st_geometry(mtq))
plot(st_geometry(mtq_z), col="red", border="green", add=T)
```


## Compter les points dans des polygones  

`st_sample()` crée des points aléatoires sur la carte de Paris. 

```{r , echo = FALSE}
set.seed(1) #Fixer l'aléa pour toujours faire la même carte.
```

```{r, nm=TRUE}
pts <- st_sample(x = mtq, size = 50)
plot(st_geometry(mtq))
plot(pts, pch = 20, col = "red", add=TRUE, cex = 1)
```

`st_interects()` crée une liste de points dans chaque polygone. 

```{r p0, nm=TRUE}
inter <- st_intersects(mtq, pts)
mtq$nbpts <- sapply(X = inter, FUN = length)
plot(st_geometry(mtq))
# display munucipalities that intersect at least 2 point
plot(st_geometry(mtq[mtq$nbpts>2,]), col = "grey", add=TRUE)
plot(pts, pch = 20, col = "red", add=TRUE, cex = 1)
```

Autre solution, faire une jointure spatiale et aggréger !

```{r p0, nm=TRUE}
mtq_counts <- mtq %>% st_join(st_as_sf(pts)) %>% count(INSEE_COM)
plot(mtq_counts %>% select(n))
plot(pts, pch = 20, col = "red", add=TRUE, cex = 1)
```


  
## Voronoi Polygons  
<small>google: "st_voronoi R sf" (https://github.com/r-spatial/sf/issues/474 & https://stackoverflow.com/questions/45719790/create-voronoi-polygon-with-simple-feature-in-r)
</small>
```{r, echo=TRUE,warning=FALSE,message=FALSE,fig.show='last',fig.height=4.5}
mtq_v <- st_voronoi(x = st_union(mtq_c))
mtq_v <- st_intersection(st_cast(mtq_v), st_union(mtq))
mtq_v <- st_join(x = st_sf(mtq_v), y = mtq_c, join=st_intersects)
mtq_v <- st_cast(mtq_v, "MULTIPOLYGON")
plot(st_geometry(mtq_v), col='lightblue')
```


## Autre traitements
- st_area(x)
- st_length(x)
- st_disjoint(x, y, sparse = FALSE)
- st_touches(x, y, sparse = FALSE)
- st_crosses(s, s, sparse = FALSE)
- st_within(x, y, sparse = FALSE)
- st_contains(x, y, sparse = FALSE)
- st_overlaps(x, y, sparse = FALSE)
- st_equals(x, y, sparse = FALSE)
- st_covers(x, y, sparse = FALSE)
- st_covered_by(x, y, sparse = FALSE)
- st_covered_by(y, y, sparse = FALSE)
- st_equals_exact(x, y,0.001, sparse = FALSE)
- ...



## Autres packages

[CRAN task views](https://cran.r-project.org/web/views/) permet d'avoir des informations sur les packages du CRAN pertinents pour des tâches reliées à certains sujets. 

[CRAN Task View: Analysis of Spatial Data](https://CRAN.R-project.org/view=Spatial):  

- Classes for spatial data   
- Handling spatial data   
- Reading and writing spatial data   
- Visualisation  
- Point pattern analysis  
- Geostatistics  
- Disease mapping and areal data analysis  
- Spatial regression  
- Ecological analysis  


# Préparer / récupérer des données 

Premier exemple les données sont stockées dans un fichier shape file. Tout devrait bien ce passer:
```{r, eval=TRUE,cache=FALSE}
library(sf)
library(dplyr)
# Import de la couche géographique (iris de Paris)
iris.fra <- st_read("../data/shp_iris/CONTOURS-IRIS.shp", stringsAsFactors = F) 
iris.75 <- iris.fra[substr(iris.fra$INSEE_COM, 1,2)=="75",c("CODE_IRIS","INSEE_COM")]
```


Un autre cas de figure fréquent, des données ponctuelles stockées dans un csv avec deux colonnes : latitude et longitude. Dans ce cas, on importe le csv puis on convertit la `data.frame` en `data.frame` spatiale (`sf`) avec la fonction `st_as_sf`.

```{r, eval=TRUE,cache=FALSE, fig.height=5}
# Import du dataset  
accidents.2019.paris <- readRDS("../data/accidents2019_paris.RDS")
# Transformation en objet sf
accidents.2019.paris <- st_as_sf(accidents.2019.paris,
                                coords = c("long", "lat"),
                                crs = 4326, agr = "constant") %>% 
  st_transform(2154)
plot(st_geometry(accidents.2019.paris))
```




```{r, eval=TRUE,cache=FALSE, fig.height=5}
inter <- st_intersects(iris.75, accidents.2019.paris)
inter_blessgravtues <- st_intersects(iris.75, accidents.2019.paris
                              %>% filter(grav%in%c(2,3)))
iris.75$nbacc <- sapply(X = inter, FUN = length)
iris.75$nbacc_blessgravtues <- sapply(X = inter_blessgravtues, FUN = length)

#Il manque 24 accidents
nrow(accidents.2019.paris)-sum(iris.75$nbacc)
plot(st_geometry(iris.75))
plot(accidents.2019.paris %>% filter(grav%in%c(1,4)) ,
     pch = 20, col = "darkgreen", add=TRUE, cex = 0.5)
plot(accidents.2019.paris %>% filter(grav%in%c(3)) ,
     pch = 20, col = "orange", add=TRUE, cex = 0.5)
plot(accidents.2019.paris %>% filter(grav==2),
     pch = 20, col = "red", add=TRUE, cex = 1)
```


## Utiliser `osmdata`


`osmdata` permet d'extraire des éléments de la base de données gratuite et open-source OpenStreetMap. Cela peut nous servir par exemple pour récupérer des élements d'habillage fleuve / routes ou d'autres informations.

```{r, eval=FALSE,cache=FALSE}
library(osmdata)
# Récupérer les routes principales grâce à osm
bb      <- iris.75 %>% st_transform(4326) %>% st_bbox()
q       <- opq(bbox = bb,timeout = 180)
qm      <- add_osm_feature (q, key = 'highway',value = 'motorway', value_exact = FALSE)
qt      <- add_osm_feature (q, key = 'highway',value = 'trunk', value_exact = FALSE)
qp      <- add_osm_feature (q, key = 'highway',value = 'primary', value_exact = FALSE)

motorway<- osmdata_sf(qm)
trunk   <- osmdata_sf(qt)
primary <- osmdata_sf(qp)

roads    <- c(primary,trunk,motorway)$osm_lines %>% st_transform(st_crs(iris.75))
roads.geom = st_intersection(st_geometry(roads),iris.75) 

# Récupérer le shape de la seine 
qr <- q %>% 
  add_osm_feature (key = 'waterway') %>% 
  add_osm_feature(key = "name:fr", value = "La Seine")
river <- osmdata_sf(qr)

river.geom <- c(st_geometry(river$osm_lines),st_geometry(river$osm_multilines)) %>% st_transform(st_crs(iris.75))
#river.geom <- st_geometry(river$osm_lines %>% filter(name.fr == "La Seine")) %>%
#  st_transform(st_crs(iris.75))

# Export road and river layers to shapefile
st_write(roads.geom, dsn = "data/osmdata/road.shp")
st_write(river.geom, dsn = "lecture/data/osmdata/river.shp")
```

```{r , echo = FALSE}
roads.geom <- st_read(dsn = "data/osmdata/road.shp", quiet = TRUE)
river.geom <- st_read(dsn = "data/osmdata/river.shp", quiet = TRUE)
```

```{r, eval=TRUE,cache=FALSE, fig.height=4.75}
# bbox est utilisé pour centrer sur Paris
bb <- st_bbox(iris.75)
par(mar=c(0.2,0.2,1.4,0.2), bg="ivory")
plot(st_geometry(iris.75), col = "ivory", border="ivory3", 
     xlim = bb[c(1,3)], ylim =  bb[c(2,4)])
plot(st_geometry(roads.geom),col="#666666",lwd = 1.2,add=TRUE)
plot(st_geometry(river.geom),col="#87cdde",lwd = 3,add=TRUE)
plot(accidents.2019.paris %>% filter(grav==3) , pch = 20, col = "orange", add=TRUE, cex = 1)
plot(accidents.2019.paris %>% filter(grav==2) , pch = 20, col = "red", add=TRUE, cex = 1)
```


## Géocodage

```{r p1, eval=TRUE,cache=TRUE, fig.height=4.75}
# avec banR
library(banR)
geo_banR = accidents.2019.paris %>% 
  filter(catv %in% c("VAE","EDP à moteur")) %>% slice(1:10) %>% 
  geocode_tbl(adresse = voie,code_insee = com) %>% select(latitude,longitude) %>%
  st_as_sf(coords = c("longitude", "latitude"),crs = 4326, agr = "constant") %>%
  st_transform(2154)


library(tidygeocoder)
geo_tidygeocoder = accidents.2019.paris %>% 
  filter(catv %in% c("VAE","EDP à moteur")) %>% slice(1:10) %>%
  mutate(addr = paste(voie,", Paris, France")) %>%  
  geocode(addr,method="osm") %>% select(lat,long) %>%
  st_as_sf(coords = c("long", "lat"),crs = 4326, agr = "constant") %>%
  st_transform(2154)

st_distance(geo_banR,geo_tidygeocoder,by_element = TRUE)
```



# Faire des cartes interactive avec R  

De nombreuses solutions existent pour faire des cartes avec R :

- `ggplot2` est un package très utilisé pour faire tous types de graphiques, et a été adapté spécifiquement aux cartes (`geom_sf`). 
- Le package `tmap` contient des fonctionnalités avancées basées sur la logique de `ggplot2`
- `map_sf` (anciennement `cartography`) s'appuie sur un langage dit "base R" et permet de faire des représentations cartographiques, basiques comme avancées.
- `mapview`, `leaflet` et `mapdeck` permettent de faire des cartes interactives. 

Par simplicité, nous nous concentrons ici sur `ggplot2` pour la partie statique et `mapview` pour la partie interactive.


## Petite introduction de sémiologie graphique 

<img src="img/lightsemio.png" alt="Light Semiology" width="100%">




## Cartes interactives `mapview` 

Les cartes interactives ne sont pas forcément très pertinentes pour représenter des informations géostatistiques. 

En revanche, elles sont utiles pour explorer les bases de données. Voyons un exemple avec `mapview` concernant les accidents mortels à Paris en 2019. 

```{r, cache=FALSE}
#remotes::install_github("r-spatial/mapview")
library(mapview)
mapviewOptions(fgb=FALSE)
# construire une carte avec certaines options pour les cercles
# avec mapview la taille des cercles reste constante quel que soit le zoom. 
# grav = 2 : individus tués
mapview(accidents.2019.paris %>%
          filter(grav==2))
```



On customise un peu...



```{r, cache=FALSE}
mapview(accidents.2019.paris %>%
          filter(grav==2),
        map.types = "Stamen.TonerLite", legend=FALSE,
        cex=5, col.regions="#217844", lwd=0, alpha=0.9)
```



On customise encore un peu plus...



```{r, cache=FALSE}
mapview(accidents.2019.paris %>%
          filter(grav==2) %>%
          mutate(age=2019-an_nais),
        map.types = "Stamen.TonerLite", legend=FALSE,
        cex="age", zcol="sexe", lwd=0, alpha=0.9)
```

# `ggplot2` et cartes statiques 

## ggplot2

### grammar of graphics 

- "The Grammar of Graphics" (Wilkinson, Annand and Grossman, 2005)
- grammaire &#8594; même type de description pour des graphique différents 


### Composants de la grammaires :
</ul>
<li> <span class="red">data and aesthetic mappings</span>,<br>
ex : f(data) &#8594; x position, y position, size, shape, color 
<li> <span class="red">geometric objects</span>,<br>
ex : points, lines, bars, texts 
<li> <span class="red">scales</span>,<br>
ex : f([0, 100]) &#8594; [0, 5] px
<li> <span class="red">facet specification</span>,<br>
ex : segmentation des données suivant un ou plusieurs facteurs
<li> <span class="red">statistical transformations</span>,<br> 
ex : moyenne, comptage, régression
<li> <span class="red">the coordinate system</span>.
</ul>




### Création d'un graphique :
</ul>
<li> ajout successif de layers (calques) 
<li> définissant un mapping des données vers leurs représentation
<li> (+ optionel) définition de transformations statistique 
<li> (+ optionel) définition des échelles
<li> (+ optionel) gestion du thème des titre ...
</ul>
<br><br>
! Données toujours sous forme de data.frame bien formatées



Exemple diagramme en barre :
```{r, fig.height=4.75, cache=FALSE}
ggplot(accidents.2019.paris)+geom_bar(aes(x=catv,group=sexe,fill=sexe))
```

Qui mérite quelques ajustements :
```{r, fig.height=4.75, cache=FALSE}

catv_ol = accidents.2019.paris %>% st_drop_geometry %>% count(catv) %>% arrange(n) %>% pull(catv)
gg = accidents.2019.paris %>% mutate(catv_o = factor(catv,levels=catv_ol)) %>% filter(catv_o %in% tail(catv_ol,10))

ggplot()+geom_bar(data = gg,aes(y=catv_o,group=sexe,fill=sexe))+
  scale_fill_brewer("Sexe",palette="Set1")+
  theme_bw()+
  labs(title="Nombre d'accidentés par type de véhicule et sexe",
       subtitle="à Paris en 2019, pour les hommes et les femmes ",caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021", x="",y="")
```

Quelques chose de plus exotique :
```{r, fig.height=4.75, cache=FALSE}
gg = accidents.2019.paris %>% 
  st_drop_geometry %>% 
  filter(catv %in% tail(catv_ol,9)) %>% 
  count(catv,lum,sexe) %>% 
  add_count(catv,wt=n,name="tot") %>% 
  mutate(prop = n/tot)

ggplot(gg)+geom_point(aes(y=lum,x=sexe,color=prop,size=prop))+
  facet_wrap(~catv)+
  scale_color_distiller(palette="Reds",direction=1)+
  labs(title="Part d'accidentés par type de véhicule et sexe",
       subtitle="à Paris en 2019. ",caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021", x="",y="")
```

Ou bien encore :
```{r, fig.height=4.75, cache=FALSE}
library(tidyr)
gg = accidents.2019.paris %>% 
  st_drop_geometry %>% 
  filter(catv %in% c("Bicyclette","VL seul","VU seul","EDP à moteur","Scooter < 50 cm3")) %>% 
  count(catv,sexe) %>% pivot_wider(names_from = "sexe",values_from="n")

ggplot(gg) + geom_segment(aes(x="Homme",y=Masculin,xend="Femme",yend=Féminin,color=catv)) 

ggplot(gg)+
  geom_segment(aes(x="Homme",y=Masculin,xend="Femme",yend=Féminin,color=catv))+
  geom_text(data=gg %>% filter(catv!="Scooter < 50 cm3"),aes(x="Homme",y=Masculin,label=catv,color=catv),hjust="left")+
  geom_text(data=gg %>% filter(catv!="VU seul"),aes(x="Femme",y=Féminin,label=catv,color=catv),hjust="right")+
  scale_color_discrete(guide="none")+theme_bw()+
  labs(title = "Nombre d'accidentés suivant le sexe et le type de véhicule", 
       subtitle="à Paris en 2019", caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021", x="",y="")
```


## Intégrer des données spatiales avec `geom_sf`

## Cartes avec ronds proportionnels

```{r, fig.height=4.75, cache=FALSE}
library(ggplot2)
ggplot() +
  geom_sf(data = iris.75,colour = "ivory3",fill = "ivory") +
  geom_sf(data = river.geom, colour = "azure",size=2) +
  geom_sf(data = roads.geom, colour = "#666666",size=0.5) +
  geom_sf(data = iris.75 %>%  st_centroid(),
          aes(size= nbacc), colour="#E84923CC", show.legend = 'point') +
  scale_size(name = "Nombre d'accidents",
             breaks = c(1,10,100,200),
             range = c(0,5)) +
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(iris.75)[c(1,3)],
           ylim = st_bbox(iris.75)[c(2,4)]) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(title = "Nombre d'accidents de la route à Paris par iris",
       caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021",x="",y="")
```


### Cartes avec choroplethes

```{r, fig.height=4.75, cache=FALSE}
library(RColorBrewer)
bks <- c(0,round(quantile((100*iris.75$nbacc_blessgravtues/iris.75$nbacc)[iris.75$nbacc_blessgravtues!=0], na.rm=TRUE, probs=seq(0,1,0.2)),0))
pal <- c("#FFFFFF",brewer.pal(length(bks)-1,"Reds"))

ggplot() +
  geom_sf(data = iris.75,colour = "ivory3",fill = "ivory") +
  geom_sf(data = iris.75, aes(fill = 100*nbacc_blessgravtues/nbacc), colour = "grey80") +
  geom_sf(data = river.geom, colour = "azure",size=2) +
  geom_sf(data = roads.geom, colour = "#666666",size=0.5) +
   scale_fill_gradientn(name = "Part (En %)", 
                       values=bks/max(bks),
                       colours = pal) +
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(iris.75)[c(1,3)],
           ylim = st_bbox(iris.75)[c(2,4)]) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(title = "Part des Accidents avec blessés graves et morts par iris à Paris",
       caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021", x="",y="")
```

```{r, fig.height=4.75, cache=FALSE}
library(RColorBrewer)

acc = iris.75 %>% 
  st_join(accidents.2019.paris) %>% 
  group_by(CODE_IRIS) %>% 
  summarize(nb_acc=n(),nb_vl=sum(if_else(catv=="VL seul",1,0)))


bks <- round(quantile(100*acc$nb_vl/acc$nb_acc, na.rm=TRUE, probs=seq(0,1,0.2)))
bks

acc = acc %>% mutate(txaccvl = cut(100*nb_vl/nb_acc,bks)) 
pal <- c("#FFFFFF",brewer.pal(length(bks)-1,"Reds"))

ggplot() +
  geom_sf(data = iris.75,colour = "ivory3",fill = "ivory") +
  geom_sf(data = acc, aes(fill = txaccvl)) +
  geom_sf(data = river.geom, colour = "#87cdde",size=2) +
  geom_sf(data = roads.geom, colour = "#666666",size=0.5) +
  scale_fill_brewer(name = "Part (En %)",palette = "Reds", na.value = "grey80") +
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(iris.75)[c(1,3)],
           ylim = st_bbox(iris.75)[c(2,4)]) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "ivory",color=NA)) +
  labs(title = "Part des Accidentés velos par iris à Paris",
       caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2021", x="",y="")
```






# <small> Crédits et reproductibilité</small> 

Présentation faite grâce au package `rmdformats`.

Elle s'inspire très fortement, ainsi que son tutoriel, d'une [précédente formation](https://github.com/comeetie/satRday) donnée par les mêmes auteurs avec Timothée Giraud. 

Partage de la configuration de R et des packages utilisés :

```{r}
sessionInfo()
```
